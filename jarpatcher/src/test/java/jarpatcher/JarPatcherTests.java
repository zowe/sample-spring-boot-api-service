/*
 * This program and the accompanying materials are made available and may be used, at your option, under either:
 * * Eclipse Public License v2.0, available at https://www.eclipse.org/legal/epl-v20.html, OR
 * * Apache License, version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
 *
 * Copyright Contributors to the Zowe Project.
 */
/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package jarpatcher;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Logger;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipOutputStream;

import org.apache.commons.io.FileUtils;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;

import jarpatcher.JarPatcher.CompareResult;
import jarpatcher.JarPatcher.JarPatcherError;

public class JarPatcherTests {
    private static final String ANOTHER_DATA = "other\n";
    private static final String SOME_DATA = "data\n";
    private static final String EMPTY_DATA = "";
    private static final Logger logger = Logger.getLogger(JarPatcherTests.class.getName());

    private Path tempDir;

    @Rule
    public TestName name = new TestName();

    @Before
    public void setup() throws IOException {
        tempDir = Files.createTempDirectory("test");
        logger.info(String.format("Test method: %s, temporary directory: %S", name.getMethodName(), tempDir));
    }

    @After
    public void cleanup() throws IOException {
        FileUtils.deleteQuietly(tempDir.toFile());
    }

    @Test
    public void sameArchivesRemainSame() throws ZipException, IOException {
        ArchiveDefinition def = new ArchiveDefinition().addFiles(new TestFile("dir/One.class", SOME_DATA));
        testPatchFromArchiveToAnotherArchive(def, def);
    }

    @Test
    public void filesCanBeAddedToEmptyArchive() throws ZipException, IOException {
        testPatchFromArchiveToAnotherArchive(new ArchiveDefinition(),
                new ArchiveDefinition().addFiles(new TestFile("dir/One.class", SOME_DATA)));
    }

    @Test
    public void emptyFilesCanBeAddedToEmptyArchive() throws ZipException, IOException {
        testPatchFromArchiveToAnotherArchive(new ArchiveDefinition(),
                new ArchiveDefinition().addFiles(new TestFile("dir/One.class", EMPTY_DATA)));
    }

    @Test
    public void filesCanBeAddedToDirectoryInArchive() throws ZipException, IOException {
        testPatchFromArchiveToAnotherArchive(new ArchiveDefinition().addFiles(new TestFile("dir/One.class", SOME_DATA)),
                new ArchiveDefinition().addFiles(new TestFile("dir/One.class", SOME_DATA),
                        new TestFile("dir/Second.class", SOME_DATA)));
    }

    @Test
    public void jarFilesCanBeAddedToDirectoryInArchive() throws ZipException, IOException {
        testPatchFromArchiveToAnotherArchive(new ArchiveDefinition().addFiles(new TestFile("dir/one.jar", SOME_DATA)),
                new ArchiveDefinition().addFiles(new TestFile("dir/one.jar", SOME_DATA),
                        new TestFile("dir/second.jar", SOME_DATA)));
    }

    @Test
    public void directoriesCanBeAddedToEmptyArchive() throws ZipException, IOException {
        testPatchFromArchiveToAnotherArchive(new ArchiveDefinition(),
                new ArchiveDefinition().addFiles(new TestFile("dir/")));
    }

    @Test
    public void filesCanBeDeletedFromDirectoryInArchive() throws ZipException, IOException {
        testPatchFromArchiveToAnotherArchive(
                new ArchiveDefinition().addFiles(new TestFile("dir/One.class", SOME_DATA),
                        new TestFile("dir/Second.class", SOME_DATA)),
                new ArchiveDefinition().addFiles(new TestFile("dir/One.class", SOME_DATA)));
    }

    @Test
    public void lastFileCanBeDeletedFromDirectoryInArchive() throws ZipException, IOException {
        testPatchFromArchiveToAnotherArchive(new ArchiveDefinition().addFiles(new TestFile("dir/One.class", SOME_DATA)),
                new ArchiveDefinition().addFiles(new TestFile("dir/")));
    }

    @Test
    public void directoryCanBeDeletedInArchive() throws ZipException, IOException {
        testPatchFromArchiveToAnotherArchive(new ArchiveDefinition().addFiles(new TestFile("dir/One.class", SOME_DATA)),
                new ArchiveDefinition());
    }

    @Test
    public void filesCanBeChangedInArchive() throws ZipException, IOException {
        testPatchFromArchiveToAnotherArchive(new ArchiveDefinition().addFiles(new TestFile("dir/One.class", SOME_DATA)),
                new ArchiveDefinition().addFiles(new TestFile("dir/One.class", ANOTHER_DATA)));
    }

    @Test(expected = JarPatcherError.class)
    public void invalidPathsFail() {
        new JarPatcher().run(new String[] { "diff", "a", "b", "c" });
    }

    private String createTestArchiveFromDefinition(String basename, ArchiveDefinition def) throws IOException {
        Path path = tempDir.resolve(basename + ".jar");
        FileOutputStream fos = new FileOutputStream(path.toString());
        ZipOutputStream zipOut = new ZipOutputStream(fos);
        Set<String> createdDirectories = new HashSet<>();
        for (TestFile f : def.getFiles().values()) {
            String filename = f.getFilename();
            createDirectories(filename, zipOut, createdDirectories);
            ZipEntry zipEntry = new ZipEntry(filename);
            zipEntry.setMethod(filename.endsWith(".jar") ? ZipEntry.STORED : ZipEntry.DEFLATED);
            if ((zipEntry.getMethod() == ZipEntry.STORED) && (f.getData() != null)) {
                zipEntry.setCompressedSize(f.getData().getBytes().length);
                CRC32 crc = new CRC32();
                crc.update(f.getData().getBytes());
                zipEntry.setCrc(crc.getValue());
            }
            zipOut.putNextEntry(zipEntry);
            if (f.getData() != null) {
                zipOut.write(f.getData().getBytes());
            }
            zipOut.closeEntry();
        }
        zipOut.close();
        fos.close();
        return path.toString();
    }

    private void createDirectories(String filename, ZipOutputStream zipOut, Set<String> createdDirectories)
            throws IOException {
        Path dir = Paths.get(filename).getParent();
        String dirname = (dir == null) ? null : dir.toString();
        if ((dirname != null) && !createdDirectories.contains(dirname)) {
            createDirectories(dirname, zipOut, createdDirectories);
            ZipEntry zipEntry = new ZipEntry(dirname + "/");
            zipOut.putNextEntry(zipEntry);
            zipOut.closeEntry();
            createdDirectories.add(dirname);
        }
    }

    private void testPatchFromArchiveToAnotherArchive(ArchiveDefinition oldDef, ArchiveDefinition newDef)
            throws ZipException, IOException {
        testPatchFromArchiveToAnotherArchive(oldDef, newDef, true);
        testPatchFromArchiveToAnotherArchive(oldDef, newDef, false);
    }

    private void testPatchFromArchiveToAnotherArchive(ArchiveDefinition oldDef, ArchiveDefinition newDef,
            boolean includePatcher) throws ZipException, IOException {
        logger.info("Old JAR: " + oldDef.toString());
        logger.info("New JAR: " + newDef.toString());
        JarPatcher jarPatcher = new JarPatcher();
        String oldPath = createTestArchiveFromDefinition("old", oldDef);
        String oldPath2 = createTestArchiveFromDefinition("old2", oldDef);
        String newPath = createTestArchiveFromDefinition("new", newDef);
        String patchPath = tempDir.resolve("patch.jar").toString();

        String patcherPath = null;
        String ignoredPath = null;
        if (includePatcher) {
            patcherPath = createTestArchiveFromDefinition("patcher",
                    new ArchiveDefinition().addFiles(new TestFile("jarpatcher/JarPatcher.class"),
                            new TestFile("jarpatcher/JarPatcher$CompareResult.class"),
                            new TestFile("META-INF/MANIFEST.MF")));
            ignoredPath = "jarpatcher";
        }

        boolean same = jarPatcher.createPatch(oldPath, newPath, patchPath, patcherPath);
        assertEquals(same, oldDef.equals(newDef));

        int rc = new JarPatcher().run(new String[] { "diff", oldPath2, newPath, patchPath, patcherPath });
        assertEquals(rc == 1, oldDef.equals(newDef));

        jarPatcher.applyPatch(oldPath, patchPath, ignoredPath);
        CompareResult compareResult = jarPatcher.compare(oldPath, newPath);
        logger.info("Compare result: " + compareResult.toString());
        assertTrue("patched file is not same as the target: " + compareResult.toString(),
                compareResult.archivesAreSame());

        new JarPatcher().run(new String[] { "patch", oldPath2, patchPath, ignoredPath });
        CompareResult compareResult2 = jarPatcher.compare(oldPath2, newPath);
        logger.info("Compare result: " + compareResult2.toString());
        assertTrue("patched file is not same as the target (via JarPatcher): " + compareResult2.toString(),
                compareResult2.archivesAreSame());
    }
}
