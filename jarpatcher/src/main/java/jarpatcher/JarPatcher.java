/*
 * This program and the accompanying materials are made available and may be used, at your option, under either:
 * * Eclipse Public License v2.0, available at https://www.eclipse.org/legal/epl-v20.html, OR
 * * Apache License, version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
 *
 * Copyright Contributors to the Zowe Project.
 */
/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package jarpatcher;

import lombok.ToString;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

public class JarPatcher {
    private static final Logger logger = Logger.getLogger(JarPatcher.class.getName());

    @ToString
    public static class CompareResult {
        Set<String> created = new HashSet<>();
        Set<String> deleted = new HashSet<>();
        Set<String> changed = new HashSet<>();

        public boolean archivesAreSame() {
            return created.isEmpty() && deleted.isEmpty() && changed.isEmpty();
        }

        public boolean isFileChangedOrCreated(String filename) {
            return changed.contains(filename) || created.contains(filename);
        }
    }

    public static class JarPatcherError extends RuntimeException {
        private static final long serialVersionUID = 8522323019867383326L;

        public JarPatcherError(IOException e) {
            super(e);
        }
    }

    private static final String DELETED = "_deleted_-";

    public int run(String[] args) {
        try {
            if (args[0].equals("diff")) {
                String oldPath = args[1];
                String newPath = args[2];
                String patchPath = args[3];
                String patcherPath = (args.length >= 5) ? args[4] : null;
                boolean areSame = createPatch(oldPath, newPath, patchPath, patcherPath);
                if (areSame) {
                    return 1;
                }
            } else if (args[0].equals("patch")) {
                String targetPath = args[1];
                String patchPath = args[2];
                String ignoredPrefix = (args.length >= 4) ? args[3] : null;
                applyPatch(targetPath, patchPath, ignoredPrefix);
            }
        } catch (IOException e) {
            throw new JarPatcherError(e);
        }
        return 0;
    }

    public CompareResult compare(String path1, String path2) throws IOException {
        if (logger.isLoggable(Level.INFO)) {
            logger.info(String.format("Comparing %s to %s", path1, path2));
        }
        try (ZipFile zipFile1 = new ZipFile(new File(path1)); ZipFile zipFile2 = new ZipFile(new File(path2))) {
            Set<String> files1 = setFromEntryNames(zipFile1);
            Set<String> files2 = setFromEntryNames(zipFile2);
            if (logger.isLoggable(Level.INFO)) {
                logger.info(String.format("Files in %s: %s", path1, files1));
                logger.info(String.format("Files in %s: %s", path2, files2));
            }

            CompareResult result = new CompareResult();
            Set<String> inBoth = files1.stream().distinct().filter(files2::contains).collect(Collectors.toSet());
            for (String filename : inBoth) {
                if (!compareEntries(zipFile1.getEntry(filename), zipFile2.getEntry(filename))) {  // NOSONAR
                    printEntry(zipFile1, zipFile1.getEntry(filename));  // NOSONAR
                    printEntry(zipFile2, zipFile2.getEntry(filename));  // NOSONAR
                    result.changed.add(filename);
                }
            }
            result.deleted
                    .addAll(files1.stream().distinct().filter(f -> !files2.contains(f)).collect(Collectors.toSet()));
            result.created
                    .addAll(files2.stream().distinct().filter(f -> !files1.contains(f)).collect(Collectors.toSet()));

            return result;
        }
    }

    private void printEntry(ZipFile f, ZipEntry entry) {  // NOSONAR
        if (logger.isLoggable(Level.INFO)) {
            logger.info(String.format("zipFile=%s file=%s size=%d crc=%d dir=%b comment=%s method=%s", f.getName(),
                    entry.getName(), entry.getSize(), entry.getCrc(), entry.isDirectory(), entry.getComment(),
                    entry.getMethod()));
        }
    }

    private boolean compareEntries(ZipEntry entry1, ZipEntry entry2) {  // NOSONAR
        return (entry1.isDirectory() == entry2.isDirectory()) && (entry1.getSize() == entry2.getSize())
                && (entry1.getName().equals(entry2.getName())) && (entry1.getCrc() == entry2.getCrc()
                && (entry1.isDirectory() || (entry1.getMethod() == entry2.getMethod())));
    }

    private Set<String> setFromEntryNames(ZipFile zipFile) {
        Enumeration<? extends ZipEntry> entries = zipFile.entries();
        Set<String> set = new HashSet<>();
        while (entries.hasMoreElements()) {
            ZipEntry entry = entries.nextElement();  // NOSONAR
            set.add(entry.getName());
        }
        return set;
    }

    private void addChangedOrCreatedFiles(String newPath, CompareResult result, ZipOutputStream zipOut)
            throws IOException {
        try (ZipInputStream zipIn = new ZipInputStream(new FileInputStream(newPath))) {
            ZipEntry inEntry = zipIn.getNextEntry();  // NOSONAR
            while (inEntry != null) {
                String filename = inEntry.getName();
                if (result.isFileChangedOrCreated(filename)) {
                    ZipEntry patchEntry = new ZipEntry(filename);
                    copyZipEntryAttributes(inEntry, patchEntry);
                    zipOut.putNextEntry(patchEntry);
                    if (!inEntry.isDirectory()) {
                        copyStream(zipIn, zipOut);
                    }
                    zipOut.closeEntry();
                }
                inEntry = zipIn.getNextEntry();  // NOSONAR
            }
        }
    }

    private void copyStream(InputStream zipIn, OutputStream zipOut) throws IOException {
        byte[] buffer = new byte[4096];
        int len;
        while ((len = zipIn.read(buffer)) > 0) {
            zipOut.write(buffer, 0, len);
        }
    }

    private void addDeletedEntries(Set<String> deletedFiles, ZipOutputStream zipOut) throws IOException {
        for (String filename : deletedFiles) {
            ZipEntry patchEntry = new ZipEntry(DELETED + filename);
            zipOut.putNextEntry(patchEntry);
            zipOut.closeEntry();
        }
    }

    private void addFiles(String fromPath, ZipOutputStream zipOut, String ignoredPath) throws IOException {
        try (ZipInputStream zipIn = new ZipInputStream(new FileInputStream(fromPath))) {
            ZipEntry inEntry = zipIn.getNextEntry();  // NOSONAR
            while (inEntry != null) {
                String filename = inEntry.getName();
                if (!filename.startsWith(ignoredPath)) {
                    ZipEntry patchEntry = new ZipEntry(filename);
                    zipOut.putNextEntry(patchEntry);
                    if (!inEntry.isDirectory()) {
                        byte[] buffer = new byte[1024];
                        int len;
                        while ((len = zipIn.read(buffer)) > 0) {
                            zipOut.write(buffer, 0, len);
                        }
                    }
                    zipOut.closeEntry();
                }
                inEntry = zipIn.getNextEntry();  // NOSONAR
            }
        }
    }

    public boolean createPatch(String oldPath, String newPath, String patchPath, String patcherPath)
            throws IOException {
        CompareResult result = compare(oldPath, newPath);
        if (logger.isLoggable(Level.INFO)) {
            logger.info(String.format("Comparing %s and %s: %s", oldPath, newPath, result));
        }

        try (FileOutputStream fos = new FileOutputStream(patchPath);
             ZipOutputStream zipOut = new ZipOutputStream(fos)) {

            addChangedOrCreatedFiles(newPath, result, zipOut);
            addDeletedEntries(result.deleted, zipOut);
            if (patcherPath != null) {
                addFiles(patcherPath, zipOut, "META-INF");
            }
        }

        return result.archivesAreSame();
    }

    private void createDirectories(String filename, ZipOutputStream zipOut, Set<String> createdDirectories)
            throws IOException {
        Path dir = Paths.get(filename).getParent();
        String dirname = (dir == null) ? null : (dir.toString() + "/");
        if ((dirname != null) && !createdDirectories.contains(dirname)) {
            createDirectories(dirname, zipOut, createdDirectories);
            ZipEntry zipEntry = new ZipEntry(dirname);
            zipOut.putNextEntry(zipEntry);
            zipOut.closeEntry();
            createdDirectories.add(dirname);
        }
    }

    public void applyPatch(String targetPath, String patchPath, String ignoredPath) throws IOException {
        String originalTargetPath = targetPath + "-original";
        Files.copy(Paths.get(targetPath), Paths.get(originalTargetPath), StandardCopyOption.REPLACE_EXISTING);
        try (FileOutputStream fos = new FileOutputStream(targetPath);
             ZipOutputStream zipOut = new ZipOutputStream(fos)) {
            Set<String> deletedOrPatchedNames = new HashSet<>();
            int keeping = 0;

            ZipFile zipPatch = new ZipFile(patchPath);
            Enumeration<? extends ZipEntry> entries = zipPatch.entries();
            try {
                while (entries.hasMoreElements()) {
                    ZipEntry entry = entries.nextElement();  // NOSONAR
                    processPatchEntry(ignoredPath, zipOut, deletedOrPatchedNames, zipPatch, entry);
                }
            } finally {
                zipPatch.close();
            }

            ZipFile zipIn = new ZipFile(originalTargetPath);
            entries = zipIn.entries();
            try {
                while (entries.hasMoreElements()) {
                    ZipEntry entry = entries.nextElement();  // NOSONAR
                    String filename = entry.getName();

                    if (!deletedOrPatchedNames.contains(filename)) {
                        keeping++;
                        deletedOrPatchedNames.add(filename);
                        writeEntry(zipOut, deletedOrPatchedNames, zipIn, entry, filename);
                    }
                }
            } finally {
                zipIn.close();
            }

            if (logger.isLoggable(Level.INFO)) {
                logger.info(String.format("Keeping %d ZIP entries", keeping));
            }
        }
        Files.delete(Paths.get(originalTargetPath));
    }

    private void processPatchEntry(String ignoredPath, ZipOutputStream zipOut, Set<String> deletedOrPatchedNames,
                                   ZipFile zipPatch, ZipEntry entry) throws IOException {  // NOSONAR
        String filename = entry.getName();
        if (filename.startsWith(DELETED)) {
            String realFilename = filename.substring(DELETED.length());
            if (logger.isLoggable(Level.INFO)) {
                logger.info(String.format("Deleting: %s", realFilename));
            }
            deletedOrPatchedNames.add(realFilename);
        } else if ((ignoredPath != null) && (filename.startsWith(ignoredPath))) {
            if (logger.isLoggable(Level.INFO)) {
                logger.info(String.format("Ignoring: %s", filename));
            }
        } else {
            if (logger.isLoggable(Level.INFO)) {
                logger.info(String.format("Patching: %s", filename));
            }
            deletedOrPatchedNames.add(filename);
            writeEntry(zipOut, deletedOrPatchedNames, zipPatch, entry, filename);
        }
    }

    private void writeEntry(ZipOutputStream zipOut, Set<String> createdDirectories, ZipFile zipPatch, ZipEntry entry,  // NOSONAR
                            String filename) throws IOException {
        createDirectories(filename, zipOut, createdDirectories);
        ZipEntry zipEntry = new ZipEntry(filename);
        copyZipEntryAttributes(entry, zipEntry);
        try (InputStream inputStream = zipPatch.getInputStream(entry)) {
            zipOut.putNextEntry(zipEntry);
            copyStream(inputStream, zipOut);
        } finally {
            zipOut.closeEntry();
        }
    }

    private void copyZipEntryAttributes(ZipEntry inEntry, ZipEntry outEntry) {  // NOSONAR
        outEntry.setMethod(inEntry.getMethod());
        outEntry.setComment(inEntry.getComment());
        if (inEntry.getMethod() == ZipEntry.STORED) {
            outEntry.setCrc(inEntry.getCrc());
            outEntry.setCompressedSize(inEntry.getCompressedSize());
        }
    }

    public static void main(String[] args) {  // NOSONAR: Arguments are validated by JarPatcher
        System.setProperty("java.util.logging.SimpleFormatter.format", "%5$s %n");
        System.exit(new JarPatcher().run(args));
    }

}
